material {
    name : ssao,
    parameters : [
        {
           type : sampler2d,
           name : depth
        }
    ],
    variables : [
         viewRay
    ],
    vertexDomain : device,
    depthWrite : false,
    depthCulling : false,
    shadingModel : unlit,
    variantFilter : [ skinning ],
    culling: none
}

vertex {
    void materialVertex(inout MaterialVertexInputs material) {
        // far-plane in view space
        material.viewRay.xyz = mulMat4x4Float3(getViewFromClipMatrix(), getPosition().xyz).xyz;
    }
}

fragment {

    float rand(float n) {
        return fract(sin(n) * 43758.5453123) * 2.0 - 1.0;
    }

    void material(inout MaterialInputs material) {
        prepareMaterial(material);

        // TODO: from UBO -- linearize depth
        const float ProjectionA = 50.0 / (50.0 - 0.1);
        const float ProjectionB = (-50.0 * 0.1) / (50.0 - 0.1);

        // clamp the view-space position at a plane with z=1
        vec3 viewRay = normalize(vec3(variable_viewRay.xy / variable_viewRay.z, 1.0));

        // read depth texture
        vec2 uv = (gl_FragCoord.xy + 0.5) * frameUniforms.resolution.zw;
        float depth = texture(materialParams_depth, uv).r;
        float linearDepth = ProjectionB / (depth - ProjectionA);

        vec3 origin = viewRay * linearDepth;

        float occlusion = 0.0;
        const float radius = 1.0;
        const uint sampleCount = 32;
        for (uint i=0 ; i<sampleCount ; i++) {
            float scale = float(i) / float(sampleCount);
            vec3 r = vec3(rand(scale), rand(2*scale), rand(3*scale));
            r = normalize(r) * (rand(4*scale) * 0.5 + 0.5);
            r *= mix(0.1f, 1.0f, scale * scale);

            vec3 samples = origin + r * radius;

            vec4 offset = mulMat4x4Float3(getClipFromViewMatrix(), samples);
            offset.xy *= 1.0 / offset.w;
            offset.xy = offset.xy * 0.5 + 0.5;

            float sampleDepth = texture(materialParams_depth, offset.xy).r;
            float linearSampleDepth = ProjectionB / (sampleDepth - ProjectionA);

            float rangeCheck = abs(origin.z - linearSampleDepth) < radius ? 1.0 : 0.0;
            occlusion += (linearSampleDepth <= samples.z ? 1.0 : 0.0) * rangeCheck;
        }

        material.baseColor = vec4(1.0 - occlusion / sampleCount);
    }
}
